def writeODEFunction( SciPyModel ):
    ''' 
        Create a derivative function from the provided 
        SciPyModel as a basis for other internal packaged
        methods. The derivative function is stored as a 
        bytearray and written to a file when needed to be
        called by each internal method.

        To Do
        -----
        1. Implement a method to check if SciPyModel 
           structure is of proper form, i.e. there are
           sufficent state variables and parameters as
           needed by highest vector indecies in rxns.

        Parameters
        ----------
        SciPyModel : internal object instance
        
        Returns
        -------
        SciPyModel : internal object instance
            SciPyModel object with derivative function as
            specified by reaction declarations.
            
        See Also
        --------
        
        
        Notes
        -----
        
    '''
    # Enable printing of full sized numpy arrays/matrix
    import numpy
    numpy.set_printoptions(threshold=numpy.nan)
    
    # Write header information for the derivative function file.
    generated_code = bytearray('')
    generated_code.extend('from __future__ import division \n')
    generated_code.extend('import numpy, sympy \n')
    generated_code.extend('\n')
    generated_code.extend('def ode_fun( y, t, p ): \n')
    generated_code.extend('\n')
    generated_code.extend(
        '    rxn = numpy.zeros([' + str(SciPyModel.Reactions.Quantity) + ']) \n')
    
    # Loop over each reaction within the SciPyModel object.
    for rxn_ix in range(SciPyModel.Reactions.Quantity):

        # Get information about the current reaction
        Formula = SciPyModel.Reactions.Formulas[rxn_ix]
        
        # Append each formula declaration to the growing output bytearray.
        generated_code.extend(
            '    # ' + SciPyModel.Reactions.Names[rxn_ix] + '\n')
        generated_code.extend('    rxn[' + str(rxn_ix) + '] = ' + Formula + '\n')
    
    # Write out footer information for the derivative function file
    generated_code.extend('\n')
    generated_code.extend('    S = numpy.' + repr(SciPyModel.Reactions.Stoichiometry) 
                          + '\n')
    generated_code.extend('    \n')
    generated_code.extend('    dy = S.dot(rxn) \n')
    generated_code.extend('    return dy \n')
    
    # Write function definition for reactions -- edit this to isolate shape/kinetic parameters
    generated_code.extend('\n')
    generated_code.extend('\n')
    generated_code.extend('def rxn_fun( y, t, p ): \n')
    generated_code.extend('\n')
    generated_code.extend(
        '    rxn = sympy.zeros(' + str(SciPyModel.Reactions.Quantity) + ',1) \n')
    for rxn_ix in range(SciPyModel.Reactions.Quantity):
        Formula = SciPyModel.Reactions.Formulas[rxn_ix]
        generated_code.extend(
            '    # ' + SciPyModel.Reactions.Names[rxn_ix] + '\n')
        generated_code.extend('    rxn[' + str(rxn_ix) + '] = ' + Formula + '\n')
    generated_code.extend('    return rxn \n')
    
    
    # Place generated bytearray code into the derivative function
    SciPyModel.ToolboxFunctions.DerivativeFunction = generated_code
    
    
    return SciPyModel